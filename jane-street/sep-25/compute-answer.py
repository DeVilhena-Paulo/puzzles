# compute-answer.py
#
# Code to check that the solution generated by or-tools is correct and to
# compute the final answer to the puzzle.


# -----------------------------------------------------------------------------
# Libraries.

from functools import reduce


# -----------------------------------------------------------------------------
# 1. Solution to puzzle generated by or-tools.

solution = {
    'digits': [
        [0, 5, 5, 5, 5, 5, 7, 0, 9],
        [0, 4, 0, 4, 0, 0, 7, 8, 9],
        [0, 6, 6, 6, 6, 0, 0, 8, 0],
        [0, 6, 0, 0, 3, 0, 7, 8, 9],
        [4, 6, 3, 0, 1, 0, 0, 8, 0],
        [4, 0, 3, 2, 2, 0, 0, 0, 0],
        [7, 7, 0, 0, 7, 0, 7, 0, 9],
        [0, 8, 0, 0, 8, 8, 8, 0, 9],
        [0, 0, 0, 0, 9, 0, 9, 9, 9]
    ],
    'pentominoes': [
        ['.', 'I', 'I', 'I', 'I', 'I', 'U', '.' ,'U'],
        ['.', 'L', '.', 'F', '.', '.', 'U', 'U' ,'U'],
        ['.', 'L', 'F', 'F', 'F', '.', '.', 'X' ,'.'],
        ['.', 'L', '.', '.', 'F', '.', 'X', 'X' ,'X'],
        ['N', 'L', 'L', '.', 'T', '.', '.', 'X' ,'.'],
        ['N', '.', 'T', 'T', 'T', '.', '.', '.' ,'.'],
        ['N', 'N', '.', '.', 'T', '.', 'Z', '.' ,'V'],
        ['.', 'N', '.', '.', 'Z', 'Z', 'Z', '.' ,'V'],
        ['.', '.', '.', '.', 'Z', '.', 'V', 'V' ,'V']
    ],
    'hooks': [
        [6, 6, 6, 6, 6, 6, 7, 8, 9],
        [5, 5, 5, 5, 5, 6, 7, 8, 9],
        [5, 4, 4, 4, 4, 6, 7, 8, 9],
        [5, 4, 3, 3, 3, 6, 7, 8, 9],
        [5, 4, 3, 2, 1, 6, 7, 8, 9],
        [5, 4, 3, 2, 2, 6, 7, 8, 9],
        [7, 7, 7, 7, 7, 7, 7, 8, 9],
        [8, 8, 8, 8, 8, 8, 8, 8, 9],
        [9, 9, 9, 9, 9, 9, 9, 9, 9]
    ]
}

# -----------------------------------------------------------------------------
# 2. Rearrange pentominoes and hooks by types

# parameters
N = 9
ROW = range(N)
COL = range(N)
GRID = list(((r, c) for r in ROW for c in COL))
DIGIT = range(N + 1)

# compute pentominoes
pentominoes = dict()
for r in ROW:
    for c in COL:
        pentomino = solution['pentominoes'][r][c]
        if pentomino not in pentominoes:
            pentominoes[pentomino] = []
        pentominoes[pentomino].append((r, c))

# compute hooks
hooks = dict()
for r in ROW:
    for c in COL:
        h = solution['hooks'][r][c]
        if h not in hooks :
            hooks[h] = []
        hooks[h].append((r, c))

# compute selected digits
digit_per_hook = dict()
for h, shape in hooks.items():
    digits_in_shape = {solution['digits'][r][c] for r, c in shape}
    assert(len(digits_in_shape) <= 2)
    digits_in_shape -= {0}
    assert(len(digits_in_shape) == 1)
    d = digits_in_shape.pop()
    digit_per_hook[h] = d


# -----------------------------------------------------------------------------
# 3. Check solution

# digit constraint:
for h, d in digit_per_hook.items():
    count = 0;
    for r, c in hooks[h]:
        if solution['digits'][r][c] != 0:
            assert(solution['digits'][r][c] == d)
            count += 1
    assert(count == d)

# multiple by 5 constraint:
for shape in pentominoes.values():
    count = sum(solution['digits'][r][c] for r, c in shape)
    assert(count % 5 == 0)


# -----------------------------------------------------------------------------
# 4. Compute answer

def connected(cell_a, cell_b):
    (r1, c1), (r2, c2) = cell_a, cell_b
    return (solution['digits'][r1][c1] == 0 and \
            solution['digits'][r2][c2] == 0) or \
           (solution['digits'][r1][c1] != 0 and \
            solution['digits'][r2][c2] != 0)

def in_bounds(cell):
    x, y = cell
    return 0 <= x and x < N and 0 <= y and y < N

def compute_connected_regions():
    connected_regions = []
    visited = [[False for _ in COL] for _ in ROW]

    for r, c in GRID:
        if not visited[r][c]:
            region = []
            cells = [(r, c)]
            visited[r][c] = True
            while cells:
                x, y = cells.pop()
                region.append((x, y))
                for dx, dy in [(1, 0), (0, -1), (-1, 0), (0, 1)]:
                    if in_bounds((x + dx, y + dy)) and \
                       not visited[x + dx][y + dy] and \
                       connected((x, y), (x + dx, y + dy)):
                        visited[x + dx][y + dy] = True
                        cells.append((x + dx, y + dy))
            connected_regions.append(region)

    return connected_regions

def print_connected_regions(connected_regions):
    grid = [['' for _ in COL] for _ in ROW]
    for i, region in enumerate(connected_regions):
        for r, c in region:
            grid[r][c] = str(i)

    print("regions:")
    for row in grid:
        print(" ".join(row))
    print()

    print("sizes of regions:")
    for i, region in enumerate(connected_regions):
        print(f"{i}: {len(region)}")

def print_solution():
    for row in solution['digits']:
        print(" ".join(str(x) for x in row))
    print()

def unfilled(region):
    r, c = region[0]
    return solution['digits'][r][c] == 0

def compute_answer(connected_regions):
    # the answer is the product of the areas of the connected
    # groups of empty squares in the completed grid.

    answer = reduce(
        lambda x, y: x * y,
        (len(region) for region in connected_regions if unfilled(region))
    )

    return answer

def main():
    connected_regions = compute_connected_regions()
    answer = compute_answer(connected_regions)
    print(f"answer = {answer}")


if __name__ == "__main__":
    main()
